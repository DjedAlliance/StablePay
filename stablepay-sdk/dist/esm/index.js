import e, { useState as t, useCallback as n, useEffect as r, createContext as s, useContext as o, useMemo as i } from "react"; import *as a from "react-dom"; import { createWalletClient as c, custom as l } from "viem"; import { sepolia as d, mainnet as u } from "viem/chains"; import { EthereumProvider as h } from "@walletconnect/ethereum-provider"; import *as m from "path"; import *as p from "os"; import *as g from "crypto"; import w from "crypto-js"; import { getWeb3 as f, getDjedContract as v, getCoinContracts as b, getDecimals as E, getOracleAddress as y, getOracleContract as _, tradeDataPriceBuySc as C } from "djed-sdk"; import k from "web3"; function N() { return N = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, N.apply(null, arguments) } function D(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function A(e) { return e && Object.prototype.hasOwnProperty.call(e, "default") && 1 === Object.keys(e).length ? e.default : e } var I, T = A(a); if ("production" === process.env.NODE_ENV) I = T.createRoot, T.hydrateRoot; else { var S = T.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; I = function (e, t) { S.usingClientEntryPoint = !0; try { return T.createRoot(e, t) } finally { S.usingClientEntryPoint = !1 } } } class O { constructor() { this.client = null, this.account = null, this.chainId = null, this.name = "MetaMask" } isAvailable() { return !!window.ethereum && window.ethereum.isMetaMask } async connect(e) { if (!this.isAvailable()) throw new Error("MetaMask is not installed or not available."); try { const t = await window.ethereum.request({ method: "eth_requestAccounts" }), n = c({ chain: this.getChainConfig(e), transport: l(window.ethereum) }); return this.client = n, this.account = t[0], this.chainId = e, { client: this.client, account: this.account, chainId: this.chainId } } catch (e) { throw console.error("Error connecting to MetaMask:", e), new Error("Failed to connect to MetaMask.") } } async disconnect() { this.client = null, this.account = null, this.chainId = null } getClient() { return this.client } getAccount() { return this.account } getChainId() { return this.chainId } getChainConfig(e) { const t = { 1: u, 11155111: d }[e]; if (!t) throw new Error(`Unsupported chain ID: ${e}`); return t } } var x = { exports: {} }; const P = A(Object.freeze({ __proto__: null, default: {} })), j = A(m), V = A(p), F = A(g), $ = { version: "17.2.3" }.version, B = ["ðŸ” encrypt with Dotenvx: https://dotenvx.com", "ðŸ” prevent committing .env to code: https://dotenvx.com/precommit", "ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild", "ðŸ“¡ add observability to secrets: https://dotenvx.com/ops", "ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops", "ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops", "âœ… audit secrets and track compliance: https://dotenvx.com/ops", "ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops", "ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops", "ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`", "âš™ï¸  specify custom .env file path with { path: '/custom/path/.env' }", "âš™ï¸  enable debug logging with { debug: true }", "âš™ï¸  override existing env vars with { override: true }", "âš™ï¸  suppress all logs with { quiet: true }", "âš™ï¸  write to custom object with { processEnv: myObject }", "âš™ï¸  load multiple .env files with { path: ['.env.local', '.env'] }"]; function L(e) { return "string" == typeof e ? !["false", "0", "no", "off", ""].includes(e.toLowerCase()) : Boolean(e) } function R(e) { return process.stdout.isTTY ? `[2m${e}[0m` : e } const U = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm; function W(e) { console.log(`[dotenv@${$}][DEBUG] ${e}`) } function M(e) { console.log(`[dotenv@${$}] ${e}`) } function G(e) { return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "" } function Y(e, t) { let n; try { n = new URL(t) } catch (e) { if ("ERR_INVALID_URL" === e.code) { const e = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development"); throw e.code = "INVALID_DOTENV_KEY", e } throw e } const r = n.password; if (!r) { const e = new Error("INVALID_DOTENV_KEY: Missing key part"); throw e.code = "INVALID_DOTENV_KEY", e } const s = n.searchParams.get("environment"); if (!s) { const e = new Error("INVALID_DOTENV_KEY: Missing environment part"); throw e.code = "INVALID_DOTENV_KEY", e } const o = `DOTENV_VAULT_${s.toUpperCase()}`, i = e.parsed[o]; if (!i) { const e = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`); throw e.code = "NOT_FOUND_DOTENV_ENVIRONMENT", e } return { ciphertext: i, key: r } } function z(e) { let t = null; if (e && e.path && e.path.length > 0) if (Array.isArray(e.path)) for (const n of e.path) P.existsSync(n) && (t = n.endsWith(".vault") ? n : `${n}.vault`); else t = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`; else t = j.resolve(process.cwd(), ".env.vault"); return P.existsSync(t) ? t : null } function K(e) { return "~" === e[0] ? j.join(V.homedir(), e.slice(1)) : e } const q = { configDotenv: function (e) { const t = j.resolve(process.cwd(), ".env"); let n = "utf8", r = process.env; e && null != e.processEnv && (r = e.processEnv); let s = L(r.DOTENV_CONFIG_DEBUG || e && e.debug), o = L(r.DOTENV_CONFIG_QUIET || e && e.quiet); e && e.encoding ? n = e.encoding : s && W("No encoding is specified. UTF-8 is used by default"); let i, a = [t]; if (e && e.path) if (Array.isArray(e.path)) { a = []; for (const t of e.path) a.push(K(t)) } else a = [K(e.path)]; const c = {}; for (const t of a) try { const r = q.parse(P.readFileSync(t, { encoding: n })); q.populate(c, r, e) } catch (e) { s && W(`Failed to load ${t} ${e.message}`), i = e } const l = q.populate(r, c, e); if (s = L(r.DOTENV_CONFIG_DEBUG || s), o = L(r.DOTENV_CONFIG_QUIET || o), s || !o) { const e = Object.keys(l).length, t = []; for (const e of a) try { const n = j.relative(process.cwd(), e); t.push(n) } catch (t) { s && W(`Failed to load ${e} ${t.message}`), i = t } M(`injecting env (${e}) from ${t.join(",")} ${R(`-- tip: ${B[Math.floor(Math.random() * B.length)]}`)}`) } return i ? { parsed: c, error: i } : { parsed: c } }, _configVault: function (e) { const t = L(process.env.DOTENV_CONFIG_DEBUG || e && e.debug), n = L(process.env.DOTENV_CONFIG_QUIET || e && e.quiet); !t && n || M("Loading env from encrypted .env.vault"); const r = q._parseVault(e); let s = process.env; return e && null != e.processEnv && (s = e.processEnv), q.populate(s, r, e), { parsed: r } }, _parseVault: function (e) { const t = z(e = e || {}); e.path = t; const n = q.configDotenv(e); if (!n.parsed) { const e = new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`); throw e.code = "MISSING_DATA", e } const r = G(e).split(","), s = r.length; let o; for (let e = 0; e < s; e++)try { const t = Y(n, r[e].trim()); o = q.decrypt(t.ciphertext, t.key); break } catch (t) { if (e + 1 >= s) throw t } return q.parse(o) }, config: function (e) { if (0 === G(e).length) return q.configDotenv(e); const t = z(e); return t ? q._configVault(e) : (n = `You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`, console.error(`[dotenv@${$}][WARN] ${n}`), q.configDotenv(e)); var n }, decrypt: function (e, t) { const n = Buffer.from(t.slice(-64), "hex"); let r = Buffer.from(e, "base64"); const s = r.subarray(0, 12), o = r.subarray(-16); r = r.subarray(12, -16); try { const e = F.createDecipheriv("aes-256-gcm", n, s); return e.setAuthTag(o), `${e.update(r)}${e.final()}` } catch (e) { const t = e instanceof RangeError, n = "Invalid key length" === e.message, r = "Unsupported state or unable to authenticate data" === e.message; if (t || n) { const e = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)"); throw e.code = "INVALID_DOTENV_KEY", e } if (r) { const e = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY"); throw e.code = "DECRYPTION_FAILED", e } throw e } }, parse: function (e) { const t = {}; let n, r = e.toString(); for (r = r.replace(/\r\n?/gm, "\n"); null != (n = U.exec(r));) { const e = n[1]; let r = n[2] || ""; r = r.trim(); const s = r[0]; r = r.replace(/^(['"`])([\s\S]*)\1$/gm, "$2"), '"' === s && (r = r.replace(/\\n/g, "\n"), r = r.replace(/\\r/g, "\r")), t[e] = r } return t }, populate: function (e, t, n = {}) { const r = Boolean(n && n.debug), s = Boolean(n && n.override), o = {}; if ("object" != typeof t) { const e = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate"); throw e.code = "OBJECT_REQUIRED", e } for (const n of Object.keys(t)) Object.prototype.hasOwnProperty.call(e, n) ? (!0 === s && (e[n] = t[n], o[n] = t[n]), r && W(!0 === s ? `"${n}" is already defined and WAS overwritten` : `"${n}" is already defined and was NOT overwritten`)) : (e[n] = t[n], o[n] = t[n]); return o } }; x.exports.configDotenv = q.configDotenv, x.exports._configVault = q._configVault, x.exports._parseVault = q._parseVault, x.exports.config = q.config, x.exports.decrypt = q.decrypt, x.exports.parse = q.parse, x.exports.populate = q.populate, x.exports = q, D(x.exports).config(); class J { constructor() { this.provider = null, this.client = null, this.account = null, this.chainId = null, this.name = "WalletConnect" } isAvailable() { return !0 } async connect(e) { const t = process.env.PROJECT_ID; if (!t) throw new Error("WalletConnect projectId is not configured."); try { this.provider = await h.init({ projectId: t, chains: [e], showQrModal: !0 }), await this.provider.enable(); const n = c({ chain: this.getChainConfig(e), transport: l(this.provider) }), r = await n.getAddresses(); return this.client = n, this.account = r[0], this.chainId = e, { client: this.client, account: this.account, chainId: this.chainId } } catch (e) { throw console.error("Error connecting to WalletConnect:", e), new Error("Failed to connect with WalletConnect.") } } async disconnect() { this.provider && await this.provider.disconnect(), this.provider = null, this.client = null, this.account = null, this.chainId = null } getClient() { return this.client } getAccount() { return this.account } getChainId() { return this.chainId } getChainConfig(e) { const t = { 1: u, 11155111: d }[e]; if (!t) throw new Error(`Unsupported chain ID: ${e}`); return t } } class Q { constructor() { this.client = null, this.account = null, this.chainId = null, this.name = "Coinbase Wallet" } isAvailable() { return !!window.ethereum && (window.ethereum.isCoinbaseWallet || window.ethereum.providers && window.ethereum.providers.find(e => e.isCoinbaseWallet)) } getProvider() { return this.isAvailable() ? window.ethereum.isCoinbaseWallet ? window.ethereum : window.ethereum.providers.find(e => e.isCoinbaseWallet) : null } async connect(e) { const t = this.getProvider(); if (!t) throw new Error("Coinbase Wallet is not installed or not available."); try { const n = await t.request({ method: "eth_requestAccounts" }), r = c({ chain: this.getChainConfig(e), transport: l(t) }); return this.client = r, this.account = n[0], this.chainId = e, { client: this.client, account: this.account, chainId: this.chainId } } catch (e) { throw console.error("Error connecting to Coinbase Wallet:", e), new Error("Failed to connect to Coinbase Wallet.") } } async disconnect() { this.client = null, this.account = null, this.chainId = null } getClient() { return this.client } getAccount() { return this.account } getChainId() { return this.chainId } getChainConfig(e) { const t = { 1: u, 11155111: d }[e]; if (!t) throw new Error(`Unsupported chain ID: ${e}`); return t } } const H = "stablepay_wallet_session", X = "stablepay-super-secret-key"; class Z { constructor(e) { this.chainId = e, this.adapters = { metamask: new O, walletconnect: new J, coinbase: new Q }, this.activeAdapter = null, this.client = null, this.account = null } async connect(e) { const t = this.adapters[e.toLowerCase()]; if (!t) throw new Error(`Wallet "${e}" is not supported.`); if (!t.isAvailable()) throw new Error(`Wallet "${e}" is not available.`); const { client: n, account: r, chainId: s } = await t.connect(this.chainId); return this.activeAdapter = t, this.client = n, this.account = r, this.saveSession(e), { client: n, account: r, chainId: s } } async disconnect() { this.activeAdapter && await this.activeAdapter.disconnect(), this.clearSession(), this.activeAdapter = null, this.client = null, this.account = null } saveSession(e) { const t = { walletName: e, timestamp: Date.now() }, n = w.AES.encrypt(JSON.stringify(t), X).toString(); localStorage.setItem(H, n) } clearSession() { localStorage.removeItem(H) } async restoreSession() { const e = localStorage.getItem(H); if (!e) return null; try { const t = w.AES.decrypt(e, X), n = JSON.parse(t.toString(w.enc.Utf8)); return Date.now() - n.timestamp > 864e5 ? (this.clearSession(), null) : await this.connect(n.walletName) } catch (e) { return console.error("Failed to restore session:", e), this.clearSession(), null } } getClient() { return this.client } getAccount() { return this.account } getAvailableWallets() { return Object.values(this.adapters).filter(e => e.isAvailable()).map(e => ({ name: e.name, id: e.name.toLowerCase().replace(" ", "") })) } } const ee = s(null), te = () => { const e = o(ee); if (!e) throw new Error("useWallet must be used within a WalletContextProvider"); return e }, ne = ({ children: s, chainId: o }) => { const [i] = t(() => new Z(o)), [a, c] = t(null), [l, d] = t(null), [u, h] = t(null), [m, p] = t(!1), [g, w] = t(!0), f = n(async e => { p(!0), h(null); try { const { client: t, account: n } = await i.connect(e); return c(t), d(n), !0 } catch (t) { return console.error(`Error connecting with ${e}:`, t), h(t.message), !1 } finally { p(!1) } }, [i]), v = n(async () => { await i.disconnect(), c(null), d(null) }, [i]); r(() => { (async () => { try { const e = await i.restoreSession(); e && (c(e.client), d(e.account)) } catch (e) { console.error("Error restoring session:", e), h("Could not restore wallet session.") } finally { w(!1) } })() }, [i]); const b = { client: a, account: l, error: u, isConnecting: m, isLoading: g, connect: f, disconnect: v, getAvailableWallets: () => i.getAvailableWallets() }; return e.createElement(ee.Provider, { value: b }, s) }, re = { light: { "--sp-bg-primary": "#ffffff", "--sp-bg-secondary": "#f7f7f7", "--sp-bg-tertiary": "#e0e0e0", "--sp-text-primary": "#1a1a1a", "--sp-text-secondary": "#555555", "--sp-accent-primary": "#f7941d", "--sp-accent-secondary": "#bc5f26", "--sp-border-primary": "#dddddd", "--sp-error": "#d9534f", "--sp-success": "#5cb85c" }, dark: { "--sp-bg-primary": "#1a1a1a", "--sp-bg-secondary": "#2a2a2a", "--sp-bg-tertiary": "#3a3a3a", "--sp-text-primary": "#ffffff", "--sp-text-secondary": "#aaaaaa", "--sp-accent-primary": "#f7941d", "--sp-accent-secondary": "#bc5f26", "--sp-border-primary": "#444444", "--sp-error": "#d9534f", "--sp-success": "#5cb85c" } }, se = s(null), oe = ({ children: n, themeConfig: s = {} }) => { const { mode: o = "auto", customTheme: a = {} } = s, [c, l] = t(o), d = i(() => { const e = JSON.parse(JSON.stringify(re)); return a.light && Object.assign(e.light, a.light), a.dark && Object.assign(e.dark, a.dark), e }, [a]); r(() => { const e = window.document.documentElement, t = t => { const n = d[t]; Object.keys(n).forEach(t => { e.style.setProperty(t, n[t]) }), e.setAttribute("data-theme", t) }, n = e => { const n = e.matches ? "dark" : "light"; "auto" === c && t(n) }; if ("auto" === c) { const e = window.matchMedia("(prefers-color-scheme: dark)"); return t(e.matches ? "dark" : "light"), e.addEventListener("change", n), () => { e.removeEventListener("change", n) } } t(c) }, [c, d]); const u = { themeMode: c, setTheme: e => { ["light", "dark", "auto"].includes(e) ? l(e) : console.warn(`Unsupported theme mode: ${e}`) } }; return e.createElement(se.Provider, { value: u }, n) }; var ie = "main_stablePayButton__UA7HC", ae = "main_logo__ITyEy", ce = "main_buttonText__N-ewy"; const le = ({ onClick: t, size: n = "medium" }) => { const r = { small: { width: "200px", height: "50px", fontSize: "14px" }, medium: { width: "250px", height: "60px", fontSize: "16px" }, large: { width: "300px", height: "70px", fontSize: "18px" } }, s = { small: { width: "35px", height: "33px" }, medium: { width: "40px", height: "38px" }, large: { width: "45px", height: "43px" } }, o = r[n] || r.medium, i = s[n] || s.medium; return e.createElement("button", { className: ie, onClick: t, style: o }, e.createElement("div", { className: ae, style: i }), e.createElement("span", { className: ce }, "Pay with StablePay")) }; var de = { dialogOverlay: "PricingCard_dialogOverlay__0XJrE", pricingCard: "PricingCard_pricingCard__LrWb9", small: "PricingCard_small__J4CHj", medium: "PricingCard_medium__EVmTB", large: "PricingCard_large__A6pnX", dialogClose: "PricingCard_dialogClose__jJ1tM", pricingCardHeader: "PricingCard_pricingCardHeader__wGczA", allianceLogo: "PricingCard_allianceLogo__URa-U", stablepayTitle: "PricingCard_stablepayTitle__4t848", pricingCardBody: "PricingCard_pricingCardBody__0wKQn", selectField: "PricingCard_selectField__LBPoZ", transactionReview: "PricingCard_transactionReview__Ix-eL", transactionInfo: "PricingCard_transactionInfo__Ck-Rc", transactionLabel: "PricingCard_transactionLabel__GDux7", transactionValue: "PricingCard_transactionValue__q-xxp", infoSection: "PricingCard_infoSection__gyjMQ", infoIcon: "PricingCard_infoIcon__rraxD", infoText: "PricingCard_infoText__l4b7A", walletButton: "PricingCard_walletButton__llw4v", loading: "PricingCard_loading__2-tGA", error: "PricingCard_error__m5fK-", networkError: "PricingCard_networkError__zR-36", errorText: "PricingCard_errorText__qZRJt" }; const ue = ({ children: t, onClose: n, size: r = "medium" }) => e.createElement("div", { className: de.dialogOverlay }, e.createElement("div", { className: `${de.pricingCard} ${de[r]}` }, e.createElement("button", { className: de.dialogClose, onClick: n }, "Ã—"), e.createElement("div", { className: de.pricingCardHeader }, e.createElement("div", { className: de.allianceLogo }), e.createElement("h2", { className: de.stablepayTitle }, "StablePay")), e.createElement("div", { className: de.pricingCardBody }, t))); class he { constructor(e) { this.networkSelector = e, this.selectedToken = null } selectToken(e) { const t = this.networkSelector.getSelectedNetworkConfig(); return !(!t || !t.tokens[e]) && (this.selectedToken = { key: e, ...t.tokens[e] }, !0) } getSelectedToken() { return this.selectedToken } getAvailableTokens() { const e = this.networkSelector.getSelectedNetworkConfig(); return e ? Object.entries(e.tokens).map(([e, t]) => ({ key: e, ...t })) : [] } resetSelection() { this.selectedToken = null } } const me = s(), pe = ({ children: n, networkSelector: s }) => { const [o] = t(() => new he(s)), [i, a] = t(null), [c, l] = t(null), [d, u] = t(null), h = () => { l(null), u(null) }; return r(() => { a(s.selectedNetwork) }, [s.selectedNetwork]), e.createElement(me.Provider, { value: { networkSelector: s, tokenSelector: o, selectedNetwork: i, selectedToken: c, transactionDetails: d, setTransactionDetails: u, selectNetwork: e => !!s.selectNetwork(e) && (a(e), h(), !0), selectToken: e => { if (o.selectToken(e)) { const e = o.getSelectedToken(); return l(e), !0 } return !1 }, resetSelections: () => { s.selectNetwork(null), a(null), h() } } }, n) }, ge = () => { const e = o(me); if (void 0 === e) throw new Error("useNetwork must be used within a NetworkProvider"); return e }, we = () => { const { networkSelector: t, selectedNetwork: n, selectNetwork: r } = ge(); return e.createElement("div", { className: de.selectField }, e.createElement("label", { htmlFor: "network-select" }, "Select Network"), e.createElement("select", { id: "network-select", onChange: e => { r(e.target.value) }, value: n || "" }, e.createElement("option", { value: "", disabled: !0 }, "Select a network"), Object.keys(t.availableNetworks).map(t => e.createElement("option", { key: t, value: t }, t)))) }; class fe { constructor(e, t) { this.networkUri = e, this.djedAddress = t } async init() { if (!this.networkUri || !this.djedAddress) throw new Error("Network URI and DJED address are required"); try { this.web3 = await f(this.networkUri), this.djedContract = v(this.web3, this.djedAddress); const { stableCoin: e, reserveCoin: t } = await b(this.djedContract, this.web3), { scDecimals: n, rcDecimals: r } = await E(e, t); this.stableCoin = e, this.reserveCoin = t, this.scDecimals = n, this.rcDecimals = r, this.oracleContract = await y(this.djedContract).then(e => _(this.web3, e, this.djedContract._address)), this.oracleAddress = this.oracleContract._address, console.log("Transaction initialized successfully") } catch (e) { throw console.error("Error initializing transaction:", e), e } } getBlockchainDetails() { return { web3Available: !!this.web3, djedContractAvailable: !!this.djedContract, stableCoinAddress: this.stableCoin ? this.stableCoin._address : "N/A", reserveCoinAddress: this.reserveCoin ? this.reserveCoin._address : "N/A", stableCoinDecimals: this.scDecimals, reserveCoinDecimals: this.rcDecimals, oracleAddress: this.oracleAddress || "N/A", oracleContractAvailable: !!this.oracleContract } } async handleTradeDataBuySc(e) { if (!this.djedContract) throw new Error("DJED contract is not initialized"); if ("string" != typeof e) throw new Error("Amount must be a string"); try { return (await C(this.djedContract, this.scDecimals, e)).totalBCScaled } catch (e) { throw console.error("Error fetching trade data for buying stablecoins: ", e), e } } } const ve = () => { const { networkSelector: n, tokenSelector: r, selectedNetwork: s, selectedToken: o, selectToken: i, setTransactionDetails: a } = ge(), [c, l] = t(!1), [d, u] = t(null), h = s ? r.getAvailableTokens() : []; return e.createElement("div", { className: de.selectField }, e.createElement("label", { htmlFor: "token-select" }, "Select Token"), e.createElement("select", { id: "token-select", onChange: async e => { const t = e.target.value; u(null), l(!0); try { if (i(t)) { const e = n.getSelectedNetworkConfig(), o = new fe(e.uri, e.djedAddress); await o.init(); const i = n.getTokenAmount(t), c = o.getBlockchainDetails(); let l = null; "native" === t && (l = await o.handleTradeDataBuySc(String(i))), a({ network: s, token: t, tokenSymbol: r.getSelectedToken().symbol, amount: i, receivingAddress: n.getReceivingAddress(), djedContractAddress: e.djedAddress, isDirectTransfer: r.getSelectedToken().isDirectTransfer || !1, isNativeToken: r.getSelectedToken().isNative || !1, tradeAmount: l ? l.amount : null, ...c }) } } catch (e) { console.error("Error fetching transaction details:", e), u("Failed to fetch transaction details. Please try again.") } finally { l(!1) } }, value: o ? o.key : "", disabled: !s || c }, e.createElement("option", { value: "", disabled: !0 }, s ? c ? "Loading..." : "Select a token" : "Please select a network first"), h.map(t => e.createElement("option", { key: t.key, value: t.key }, t.symbol, " (", t.isDirectTransfer ? "Direct Transfer" : "Native", ")"))), d && e.createElement("div", { className: de.error }, d)) }; class be { constructor(e) { if (!e) throw new Error("A provider is required for GasEstimationService."); this.web3 = new k(e), this.gasPriceCache = { prices: null, timestamp: 0 } } async getGasPrices(e = !1) { const t = Date.now(); if (!e && this.gasPriceCache.prices && t - this.gasPriceCache.timestamp < 6e4) return this.gasPriceCache.prices; try { const e = await this.web3.eth.getGasPrice(), n = parseFloat(this.web3.utils.fromWei(e, "gwei")), r = { slow: n.toFixed(2), standard: (1.2 * n).toFixed(2), fast: (1.5 * n).toFixed(2) }; return this.gasPriceCache = { prices: r, timestamp: t }, r } catch (e) { return console.error("Error fetching gas prices:", e), { slow: "5", standard: "10", fast: "15" } } } async estimateGasLimit(e) { try { const t = await this.web3.eth.estimateGas(e); return Math.ceil(1.2 * t) } catch (e) { return console.error("Error estimating gas limit:", e), 1e5 } } async calculateFee(e, t) { const n = await this.getGasPrices(), r = n[e] || n.standard, s = this.web3.utils.toWei(r, "gwei"), o = BigInt(s) * BigInt(t); return this.web3.utils.fromWei(o.toString(), "ether") } async getMaxAmount(e, t, n) { const r = await this.calculateFee(t, n), s = BigInt(this.web3.utils.toWei(e, "ether")), o = BigInt(this.web3.utils.toWei(r, "ether")); if (s > o) { const e = s - o; return this.web3.utils.fromWei(e.toString(), "ether") } return "0" } } const Ee = { slow: { label: "Slow", time: "~5-10 min" }, standard: { label: "Standard", time: "~1-3 min" }, fast: { label: "Fast", time: "< 1 min" } }, ye = ({ onFeeSelect: n, isNativeTransaction: s }) => { const { client: o } = te(), [a, c] = t(null), [l, d] = t("standard"), [u, h] = t(!0), [m, p] = t(null), g = i(() => o ? new be(o.transport) : null, [o]); return r(() => { if (!g || !s) return void h(!1); const e = async () => { h(!0), p(null); try { const e = await g.getGasPrices(); c(e) } catch (e) { console.error("Failed to fetch gas prices:", e), p("Could not load gas fees.") } finally { h(!1) } }; e(); const t = setInterval(e, 6e4); return () => clearInterval(t) }, [g, s]), r(() => { a && n && n({ speed: l, gwei: a[l] }) }, [l, a, n]), s ? u ? e.createElement("div", { className: "stablepay-fee-loading" }, "Loading fee estimates...") : m ? e.createElement("div", { className: "stablepay-fee-error" }, m) : e.createElement("div", { className: "stablepay-transaction-fee" }, e.createElement("h4", { className: "stablepay-fee-title" }, "Transaction Speed"), e.createElement("div", { className: "stablepay-fee-options" }, Object.keys(Ee).map(t => e.createElement("div", { key: t, className: "stablepay-fee-option " + (l === t ? "selected" : ""), onClick: () => d(t) }, e.createElement("div", { className: "stablepay-fee-label" }, Ee[t].label), e.createElement("div", { className: "stablepay-fee-gwei" }, a[t], " Gwei"), e.createElement("div", { className: "stablepay-fee-time" }, Ee[t].time))))) : null }, _e = ({ onClose: t, buttonSize: n }) => { const { resetSelections: r } = ge(); return e.createElement(ue, { onClose: () => { r(), t() }, size: n }, e.createElement(we, null), e.createElement(ve, null), e.createElement(ye, null)) }, Ce = ({ onClose: t, buttonSize: n, networkSelector: r }) => e.createElement(pe, { networkSelector: r }, e.createElement(ne, null, e.createElement(_e, { onClose: t, buttonSize: n }))), ke = ({ networkSelector: n, buttonSize: r = "medium" }) => { const [s, o] = t(!1); return e.createElement("div", { className: de.widgetContainer }, !s && e.createElement(le, { onClick: () => { o(!0) }, size: r }), s && e.createElement(Ce, { onClose: () => { o(!1) }, buttonSize: r, networkSelector: n })) }, Ne = { sepolia: { uri: "https://ethereum-sepolia.publicnode.com/", chainId: 11155111, djedAddress: "0x624FcD0a1F9B5820c950FefD48087531d38387f4", tokens: { stablecoin: { symbol: "SOD", address: "0x6b930182787F346F18666D167e8d32166dC5eFBD", decimals: 18, isDirectTransfer: !0 }, native: { symbol: "ETH", decimals: 18, isNative: !0 } }, feeUI: 0 }, "milkomeda-mainnet": { uri: "https://rpc-mainnet-cardano-evm.c1.milkomeda.com", chainId: 2001, djedAddress: "0x67A30B399F5Ed499C1a6Bc0358FA6e42Ea4BCe76", tokens: { stablecoin: { symbol: "MOD", address: "0xcbA90fB1003b9D1bc6a2b66257D2585011b004e9", decimals: 18, isDirectTransfer: !0 }, native: { symbol: "mADA", decimals: 18, isNative: !0 } }, feeUI: 0 }, "ethereum-classic": { uri: "https://etc.rivet.link", chainId: 61, djedAddress: "0xCc3664d7021FD36B1Fe2b136e2324710c8442cCf", tokens: { stablecoin: { symbol: "ECSD", address: "0x5A7Ca94F6E969C94bef4CE5e2f90ed9d4891918A", decimals: 18, isDirectTransfer: !0 }, native: { symbol: "ETC", decimals: 18, isNative: !0 } }, feeUI: 0 } }; class De { constructor(e = {}) { this.receivingAddress = e.receivingAddress || "", this.blacklist = e.blacklist || [], this.amounts = e.Amounts || {}, this.validateConfig() } validateConfig() { if (!this.receivingAddress) throw new Error("Receiving address is required"); for (const [e, t] of Object.entries(this.amounts)) { if (!Ne[e]) throw new Error(`Invalid network: ${e}`); if (!t.stablecoin || "number" != typeof t.stablecoin || t.stablecoin <= 0) throw new Error(`Invalid stablecoin amount for network ${e}`) } } getBlacklist() { return this.blacklist } getReceivingAddress() { return this.receivingAddress } getTokenAmount(e) { console.log("Getting amount for network:", e), console.log("Amounts object:", this.amounts); const t = this.amounts[e]?.stablecoin; return console.log("Returning amount:", t), t || 0 } } class Ae { constructor(e) { this.merchantConfig = e, this.blacklist = e.getBlacklist(), this.availableNetworks = this.getAvailableNetworks(), this.selectedNetwork = null } getAvailableNetworks() { return Object.entries(Ne).reduce((e, [t, n]) => (this.blacklist.includes(n.chainId) || (e[t] = n), e), {}) } selectNetwork(e) { return null === e ? (this.selectedNetwork = null, console.log("Network selection reset"), !0) : this.availableNetworks[e] ? (this.selectedNetwork = e, console.log(`Network selected: ${e}`), !0) : (console.error(`Invalid network: ${e}`), !1) } getSelectedNetworkConfig() { return this.selectedNetwork ? this.availableNetworks[this.selectedNetwork] : null } getReceivingAddress() { return this.merchantConfig.getReceivingAddress() } getTokenAmount(e) { return this.merchantConfig.getTokenAmount(this.selectedNetwork, e) } } const Ie = { MerchantConfig: De, NetworkSelector: Ae, Widget: ke, init: ({ target: t, networkSelector: n, theme: r, buttonSize: s = "medium", ...o }) => { const i = document.querySelector(t); if (!i) return console.error(`StablePay Error: Target element "${t}" not found.`), { destroy: () => { } }; if (!n) return console.error("StablePay Error: `networkSelector` is required."), { destroy: () => { } }; const a = I(i); return a.render(e.createElement(e.StrictMode, null, e.createElement(oe, { themeConfig: r }, e.createElement(ke, N({ networkSelector: n, buttonSize: s }, o))))), { destroy: () => { a.unmount() } } } }; export { De as MerchantConfig, Ae as NetworkSelector, oe as ThemeProvider, ne as WalletContextProvider, ke as Widget, Ie as default, ge as useNetwork, te as useWallet };
