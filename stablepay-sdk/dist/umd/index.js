!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("react-dom"),require("viem"),require("viem/chains"),require("@walletconnect/ethereum-provider"),require("path"),require("os"),require("crypto"),require("crypto-js"),require("djed-sdk"),require("web3")):"function"==typeof define&&define.amd?define(["exports","react","react-dom","viem","viem/chains","@walletconnect/ethereum-provider","path","os","crypto","crypto-js","djed-sdk","web3"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).StablePay={},e.React,e.ReactDOM,e.viem,e.viemChains,e.WalletConnectEthereumProvider,e.path$1,e.os$1,e.crypto$1,e.CryptoJS,e.DjedSdk,e.Web3)}(this,function(e,t,n,r,s,o,a,i,c,l,d,u){"use strict";function h(e){var t=Object.create(null);return e&&Object.keys(e).forEach(function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}}),t.default=e,Object.freeze(t)}var m=h(n),p=h(a),g=h(i),f=h(c);function w(){return w=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},w.apply(null,arguments)}function v(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function b(e){return e&&Object.prototype.hasOwnProperty.call(e,"default")&&1===Object.keys(e).length?e.default:e}var y,E=b(m);if("production"===process.env.NODE_ENV)y=E.createRoot,E.hydrateRoot;else{var C=E.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;y=function(e,t){C.usingClientEntryPoint=!0;try{return E.createRoot(e,t)}finally{C.usingClientEntryPoint=!1}}}class _{constructor(){this.client=null,this.account=null,this.chainId=null,this.name="MetaMask"}isAvailable(){return!!window.ethereum&&window.ethereum.isMetaMask}async connect(e){if(!this.isAvailable())throw new Error("MetaMask is not installed or not available.");try{const t=await window.ethereum.request({method:"eth_requestAccounts"}),n=r.createWalletClient({chain:this.getChainConfig(e),transport:r.custom(window.ethereum)});return this.client=n,this.account=t[0],this.chainId=e,{client:this.client,account:this.account,chainId:this.chainId}}catch(e){throw console.error("Error connecting to MetaMask:",e),new Error("Failed to connect to MetaMask.")}}async disconnect(){this.client=null,this.account=null,this.chainId=null}getClient(){return this.client}getAccount(){return this.account}getChainId(){return this.chainId}getChainConfig(e){const t={1:s.mainnet,11155111:s.sepolia}[e];if(!t)throw new Error(`Unsupported chain ID: ${e}`);return t}}var k={exports:{}};const N=b(Object.freeze({__proto__:null,default:{}})),S=b(p),D=b(g),A=b(f),T={version:"17.2.3"}.version,I=["🔐 encrypt with Dotenvx: https://dotenvx.com","🔐 prevent committing .env to code: https://dotenvx.com/precommit","🔐 prevent building .env in docker: https://dotenvx.com/prebuild","📡 add observability to secrets: https://dotenvx.com/ops","👥 sync secrets across teammates & machines: https://dotenvx.com/ops","🗂️ backup and recover secrets: https://dotenvx.com/ops","✅ audit secrets and track compliance: https://dotenvx.com/ops","🔄 add secrets lifecycle management: https://dotenvx.com/ops","🔑 add access controls to secrets: https://dotenvx.com/ops","🛠️  run anywhere with `dotenvx run -- yourcommand`","⚙️  specify custom .env file path with { path: '/custom/path/.env' }","⚙️  enable debug logging with { debug: true }","⚙️  override existing env vars with { override: true }","⚙️  suppress all logs with { quiet: true }","⚙️  write to custom object with { processEnv: myObject }","⚙️  load multiple .env files with { path: ['.env.local', '.env'] }"];function O(e){return"string"==typeof e?!["false","0","no","off",""].includes(e.toLowerCase()):Boolean(e)}function x(e){return process.stdout.isTTY?`[2m${e}[0m`:e}const P=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function j(e){console.log(`[dotenv@${T}][DEBUG] ${e}`)}function V(e){console.log(`[dotenv@${T}] ${e}`)}function F(e){return e&&e.DOTENV_KEY&&e.DOTENV_KEY.length>0?e.DOTENV_KEY:process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0?process.env.DOTENV_KEY:""}function $(e,t){let n;try{n=new URL(t)}catch(e){if("ERR_INVALID_URL"===e.code){const e=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw e.code="INVALID_DOTENV_KEY",e}throw e}const r=n.password;if(!r){const e=new Error("INVALID_DOTENV_KEY: Missing key part");throw e.code="INVALID_DOTENV_KEY",e}const s=n.searchParams.get("environment");if(!s){const e=new Error("INVALID_DOTENV_KEY: Missing environment part");throw e.code="INVALID_DOTENV_KEY",e}const o=`DOTENV_VAULT_${s.toUpperCase()}`,a=e.parsed[o];if(!a){const e=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);throw e.code="NOT_FOUND_DOTENV_ENVIRONMENT",e}return{ciphertext:a,key:r}}function W(e){let t=null;if(e&&e.path&&e.path.length>0)if(Array.isArray(e.path))for(const n of e.path)N.existsSync(n)&&(t=n.endsWith(".vault")?n:`${n}.vault`);else t=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else t=S.resolve(process.cwd(),".env.vault");return N.existsSync(t)?t:null}function B(e){return"~"===e[0]?S.join(D.homedir(),e.slice(1)):e}const R={configDotenv:function(e){const t=S.resolve(process.cwd(),".env");let n="utf8",r=process.env;e&&null!=e.processEnv&&(r=e.processEnv);let s=O(r.DOTENV_CONFIG_DEBUG||e&&e.debug),o=O(r.DOTENV_CONFIG_QUIET||e&&e.quiet);e&&e.encoding?n=e.encoding:s&&j("No encoding is specified. UTF-8 is used by default");let a,i=[t];if(e&&e.path)if(Array.isArray(e.path)){i=[];for(const t of e.path)i.push(B(t))}else i=[B(e.path)];const c={};for(const t of i)try{const r=R.parse(N.readFileSync(t,{encoding:n}));R.populate(c,r,e)}catch(e){s&&j(`Failed to load ${t} ${e.message}`),a=e}const l=R.populate(r,c,e);if(s=O(r.DOTENV_CONFIG_DEBUG||s),o=O(r.DOTENV_CONFIG_QUIET||o),s||!o){const e=Object.keys(l).length,t=[];for(const e of i)try{const n=S.relative(process.cwd(),e);t.push(n)}catch(t){s&&j(`Failed to load ${e} ${t.message}`),a=t}V(`injecting env (${e}) from ${t.join(",")} ${x(`-- tip: ${I[Math.floor(Math.random()*I.length)]}`)}`)}return a?{parsed:c,error:a}:{parsed:c}},_configVault:function(e){const t=O(process.env.DOTENV_CONFIG_DEBUG||e&&e.debug),n=O(process.env.DOTENV_CONFIG_QUIET||e&&e.quiet);!t&&n||V("Loading env from encrypted .env.vault");const r=R._parseVault(e);let s=process.env;return e&&null!=e.processEnv&&(s=e.processEnv),R.populate(s,r,e),{parsed:r}},_parseVault:function(e){const t=W(e=e||{});e.path=t;const n=R.configDotenv(e);if(!n.parsed){const e=new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`);throw e.code="MISSING_DATA",e}const r=F(e).split(","),s=r.length;let o;for(let e=0;e<s;e++)try{const t=$(n,r[e].trim());o=R.decrypt(t.ciphertext,t.key);break}catch(t){if(e+1>=s)throw t}return R.parse(o)},config:function(e){if(0===F(e).length)return R.configDotenv(e);const t=W(e);return t?R._configVault(e):(n=`You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`,console.error(`[dotenv@${T}][WARN] ${n}`),R.configDotenv(e));var n},decrypt:function(e,t){const n=Buffer.from(t.slice(-64),"hex");let r=Buffer.from(e,"base64");const s=r.subarray(0,12),o=r.subarray(-16);r=r.subarray(12,-16);try{const e=A.createDecipheriv("aes-256-gcm",n,s);return e.setAuthTag(o),`${e.update(r)}${e.final()}`}catch(e){const t=e instanceof RangeError,n="Invalid key length"===e.message,r="Unsupported state or unable to authenticate data"===e.message;if(t||n){const e=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw e.code="INVALID_DOTENV_KEY",e}if(r){const e=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw e.code="DECRYPTION_FAILED",e}throw e}},parse:function(e){const t={};let n,r=e.toString();for(r=r.replace(/\r\n?/gm,"\n");null!=(n=P.exec(r));){const e=n[1];let r=n[2]||"";r=r.trim();const s=r[0];r=r.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),'"'===s&&(r=r.replace(/\\n/g,"\n"),r=r.replace(/\\r/g,"\r")),t[e]=r}return t},populate:function(e,t,n={}){const r=Boolean(n&&n.debug),s=Boolean(n&&n.override),o={};if("object"!=typeof t){const e=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw e.code="OBJECT_REQUIRED",e}for(const n of Object.keys(t))Object.prototype.hasOwnProperty.call(e,n)?(!0===s&&(e[n]=t[n],o[n]=t[n]),r&&j(!0===s?`"${n}" is already defined and WAS overwritten`:`"${n}" is already defined and was NOT overwritten`)):(e[n]=t[n],o[n]=t[n]);return o}};k.exports.configDotenv=R.configDotenv,k.exports._configVault=R._configVault,k.exports._parseVault=R._parseVault,k.exports.config=R.config,k.exports.decrypt=R.decrypt,k.exports.parse=R.parse,k.exports.populate=R.populate,k.exports=R,v(k.exports).config();class L{constructor(){this.provider=null,this.client=null,this.account=null,this.chainId=null,this.name="WalletConnect"}isAvailable(){return!0}async connect(e){const t=process.env.PROJECT_ID;if(!t)throw new Error("WalletConnect projectId is not configured.");try{this.provider=await o.EthereumProvider.init({projectId:t,chains:[e],showQrModal:!0}),await this.provider.enable();const n=r.createWalletClient({chain:this.getChainConfig(e),transport:r.custom(this.provider)}),s=await n.getAddresses();return this.client=n,this.account=s[0],this.chainId=e,{client:this.client,account:this.account,chainId:this.chainId}}catch(e){throw console.error("Error connecting to WalletConnect:",e),new Error("Failed to connect with WalletConnect.")}}async disconnect(){this.provider&&await this.provider.disconnect(),this.provider=null,this.client=null,this.account=null,this.chainId=null}getClient(){return this.client}getAccount(){return this.account}getChainId(){return this.chainId}getChainConfig(e){const t={1:s.mainnet,11155111:s.sepolia}[e];if(!t)throw new Error(`Unsupported chain ID: ${e}`);return t}}class M{constructor(){this.client=null,this.account=null,this.chainId=null,this.name="Coinbase Wallet"}isAvailable(){return!!window.ethereum&&(window.ethereum.isCoinbaseWallet||window.ethereum.providers&&window.ethereum.providers.find(e=>e.isCoinbaseWallet))}getProvider(){return this.isAvailable()?window.ethereum.isCoinbaseWallet?window.ethereum:window.ethereum.providers.find(e=>e.isCoinbaseWallet):null}async connect(e){const t=this.getProvider();if(!t)throw new Error("Coinbase Wallet is not installed or not available.");try{const n=await t.request({method:"eth_requestAccounts"}),s=r.createWalletClient({chain:this.getChainConfig(e),transport:r.custom(t)});return this.client=s,this.account=n[0],this.chainId=e,{client:this.client,account:this.account,chainId:this.chainId}}catch(e){throw console.error("Error connecting to Coinbase Wallet:",e),new Error("Failed to connect to Coinbase Wallet.")}}async disconnect(){this.client=null,this.account=null,this.chainId=null}getClient(){return this.client}getAccount(){return this.account}getChainId(){return this.chainId}getChainConfig(e){const t={1:s.mainnet,11155111:s.sepolia}[e];if(!t)throw new Error(`Unsupported chain ID: ${e}`);return t}}const U="stablepay_wallet_session",q="stablepay-super-secret-key";class G{constructor(e){this.chainId=e,this.adapters={metamask:new _,walletconnect:new L,coinbase:new M},this.activeAdapter=null,this.client=null,this.account=null}async connect(e){const t=this.adapters[e.toLowerCase()];if(!t)throw new Error(`Wallet "${e}" is not supported.`);if(!t.isAvailable())throw new Error(`Wallet "${e}" is not available.`);const{client:n,account:r,chainId:s}=await t.connect(this.chainId);return this.activeAdapter=t,this.client=n,this.account=r,this.saveSession(e),{client:n,account:r,chainId:s}}async disconnect(){this.activeAdapter&&await this.activeAdapter.disconnect(),this.clearSession(),this.activeAdapter=null,this.client=null,this.account=null}saveSession(e){const t={walletName:e,timestamp:Date.now()},n=l.AES.encrypt(JSON.stringify(t),q).toString();localStorage.setItem(U,n)}clearSession(){localStorage.removeItem(U)}async restoreSession(){const e=localStorage.getItem(U);if(!e)return null;try{const t=l.AES.decrypt(e,q),n=JSON.parse(t.toString(l.enc.Utf8));return Date.now()-n.timestamp>864e5?(this.clearSession(),null):await this.connect(n.walletName)}catch(e){return console.error("Failed to restore session:",e),this.clearSession(),null}}getClient(){return this.client}getAccount(){return this.account}getAvailableWallets(){return Object.values(this.adapters).filter(e=>e.isAvailable()).map(e=>({name:e.name,id:e.name.toLowerCase().replace(" ","")}))}}const z=t.createContext(null),Y=()=>{const e=t.useContext(z);if(!e)throw new Error("useWallet must be used within a WalletContextProvider");return e},K=({children:e,chainId:n})=>{const[r]=t.useState(()=>new G(n)),[s,o]=t.useState(null),[a,i]=t.useState(null),[c,l]=t.useState(null),[d,u]=t.useState(!1),[h,m]=t.useState(!0),p=t.useCallback(async e=>{u(!0),l(null);try{const{client:t,account:n}=await r.connect(e);return o(t),i(n),!0}catch(t){return console.error(`Error connecting with ${e}:`,t),l(t.message),!1}finally{u(!1)}},[r]),g=t.useCallback(async()=>{await r.disconnect(),o(null),i(null)},[r]);t.useEffect(()=>{(async()=>{try{const e=await r.restoreSession();e&&(o(e.client),i(e.account))}catch(e){console.error("Error restoring session:",e),l("Could not restore wallet session.")}finally{m(!1)}})()},[r]);const f={client:s,account:a,error:c,isConnecting:d,isLoading:h,connect:p,disconnect:g,getAvailableWallets:()=>r.getAvailableWallets()};return t.createElement(z.Provider,{value:f},e)},J={light:{"--sp-bg-primary":"#ffffff","--sp-bg-secondary":"#f7f7f7","--sp-bg-tertiary":"#e0e0e0","--sp-text-primary":"#1a1a1a","--sp-text-secondary":"#555555","--sp-accent-primary":"#f7941d","--sp-accent-secondary":"#bc5f26","--sp-border-primary":"#dddddd","--sp-error":"#d9534f","--sp-success":"#5cb85c"},dark:{"--sp-bg-primary":"#1a1a1a","--sp-bg-secondary":"#2a2a2a","--sp-bg-tertiary":"#3a3a3a","--sp-text-primary":"#ffffff","--sp-text-secondary":"#aaaaaa","--sp-accent-primary":"#f7941d","--sp-accent-secondary":"#bc5f26","--sp-border-primary":"#444444","--sp-error":"#d9534f","--sp-success":"#5cb85c"}},Q=t.createContext(null),H=({children:e,themeConfig:n={}})=>{const{mode:r="auto",customTheme:s={}}=n,[o,a]=t.useState(r),i=t.useMemo(()=>{const e=JSON.parse(JSON.stringify(J));return s.light&&Object.assign(e.light,s.light),s.dark&&Object.assign(e.dark,s.dark),e},[s]);t.useEffect(()=>{const e=window.document.documentElement,t=t=>{const n=i[t];Object.keys(n).forEach(t=>{e.style.setProperty(t,n[t])}),e.setAttribute("data-theme",t)},n=e=>{const n=e.matches?"dark":"light";"auto"===o&&t(n)};if("auto"===o){const e=window.matchMedia("(prefers-color-scheme: dark)");return t(e.matches?"dark":"light"),e.addEventListener("change",n),()=>{e.removeEventListener("change",n)}}t(o)},[o,i]);const c={themeMode:o,setTheme:e=>{["light","dark","auto"].includes(e)?a(e):console.warn(`Unsupported theme mode: ${e}`)}};return t.createElement(Q.Provider,{value:c},e)};var X="main_stablePayButton__UA7HC",Z="main_logo__ITyEy",ee="main_buttonText__N-ewy";const te=({onClick:e,size:n="medium"})=>{const r={small:{width:"200px",height:"50px",fontSize:"14px"},medium:{width:"250px",height:"60px",fontSize:"16px"},large:{width:"300px",height:"70px",fontSize:"18px"}},s={small:{width:"35px",height:"33px"},medium:{width:"40px",height:"38px"},large:{width:"45px",height:"43px"}},o=r[n]||r.medium,a=s[n]||s.medium;return t.createElement("button",{className:X,onClick:e,style:o},t.createElement("div",{className:Z,style:a}),t.createElement("span",{className:ee},"Pay with StablePay"))};var ne={dialogOverlay:"PricingCard_dialogOverlay__0XJrE",pricingCard:"PricingCard_pricingCard__LrWb9",small:"PricingCard_small__J4CHj",medium:"PricingCard_medium__EVmTB",large:"PricingCard_large__A6pnX",dialogClose:"PricingCard_dialogClose__jJ1tM",pricingCardHeader:"PricingCard_pricingCardHeader__wGczA",allianceLogo:"PricingCard_allianceLogo__URa-U",stablepayTitle:"PricingCard_stablepayTitle__4t848",pricingCardBody:"PricingCard_pricingCardBody__0wKQn",selectField:"PricingCard_selectField__LBPoZ",transactionReview:"PricingCard_transactionReview__Ix-eL",transactionInfo:"PricingCard_transactionInfo__Ck-Rc",transactionLabel:"PricingCard_transactionLabel__GDux7",transactionValue:"PricingCard_transactionValue__q-xxp",infoSection:"PricingCard_infoSection__gyjMQ",infoIcon:"PricingCard_infoIcon__rraxD",infoText:"PricingCard_infoText__l4b7A",walletButton:"PricingCard_walletButton__llw4v",loading:"PricingCard_loading__2-tGA",error:"PricingCard_error__m5fK-",networkError:"PricingCard_networkError__zR-36",errorText:"PricingCard_errorText__qZRJt"};const re=({children:e,onClose:n,size:r="medium"})=>t.createElement("div",{className:ne.dialogOverlay},t.createElement("div",{className:`${ne.pricingCard} ${ne[r]}`},t.createElement("button",{className:ne.dialogClose,onClick:n},"×"),t.createElement("div",{className:ne.pricingCardHeader},t.createElement("div",{className:ne.allianceLogo}),t.createElement("h2",{className:ne.stablepayTitle},"StablePay")),t.createElement("div",{className:ne.pricingCardBody},e)));class se{constructor(e){this.networkSelector=e,this.selectedToken=null}selectToken(e){const t=this.networkSelector.getSelectedNetworkConfig();return!(!t||!t.tokens[e])&&(this.selectedToken={key:e,...t.tokens[e]},!0)}getSelectedToken(){return this.selectedToken}getAvailableTokens(){const e=this.networkSelector.getSelectedNetworkConfig();return e?Object.entries(e.tokens).map(([e,t])=>({key:e,...t})):[]}resetSelection(){this.selectedToken=null}}const oe=t.createContext(),ae=({children:e,networkSelector:n})=>{const[r]=t.useState(()=>new se(n)),[s,o]=t.useState(null),[a,i]=t.useState(null),[c,l]=t.useState(null),d=()=>{i(null),l(null)};return t.useEffect(()=>{o(n.selectedNetwork)},[n.selectedNetwork]),t.createElement(oe.Provider,{value:{networkSelector:n,tokenSelector:r,selectedNetwork:s,selectedToken:a,transactionDetails:c,setTransactionDetails:l,selectNetwork:e=>!!n.selectNetwork(e)&&(o(e),d(),!0),selectToken:e=>{if(r.selectToken(e)){const e=r.getSelectedToken();return i(e),!0}return!1},resetSelections:()=>{n.selectNetwork(null),o(null),d()}}},e)},ie=()=>{const e=t.useContext(oe);if(void 0===e)throw new Error("useNetwork must be used within a NetworkProvider");return e},ce=()=>{const{networkSelector:e,selectedNetwork:n,selectNetwork:r}=ie();return t.createElement("div",{className:ne.selectField},t.createElement("label",{htmlFor:"network-select"},"Select Network"),t.createElement("select",{id:"network-select",onChange:e=>{r(e.target.value)},value:n||""},t.createElement("option",{value:"",disabled:!0},"Select a network"),Object.keys(e.availableNetworks).map(e=>t.createElement("option",{key:e,value:e},e))))};class le{constructor(e,t){this.networkUri=e,this.djedAddress=t}async init(){if(!this.networkUri||!this.djedAddress)throw new Error("Network URI and DJED address are required");try{this.web3=await d.getWeb3(this.networkUri),this.djedContract=d.getDjedContract(this.web3,this.djedAddress);const{stableCoin:e,reserveCoin:t}=await d.getCoinContracts(this.djedContract,this.web3),{scDecimals:n,rcDecimals:r}=await d.getDecimals(e,t);this.stableCoin=e,this.reserveCoin=t,this.scDecimals=n,this.rcDecimals=r,this.oracleContract=await d.getOracleAddress(this.djedContract).then(e=>d.getOracleContract(this.web3,e,this.djedContract._address)),this.oracleAddress=this.oracleContract._address,console.log("Transaction initialized successfully")}catch(e){throw console.error("Error initializing transaction:",e),e}}getBlockchainDetails(){return{web3Available:!!this.web3,djedContractAvailable:!!this.djedContract,stableCoinAddress:this.stableCoin?this.stableCoin._address:"N/A",reserveCoinAddress:this.reserveCoin?this.reserveCoin._address:"N/A",stableCoinDecimals:this.scDecimals,reserveCoinDecimals:this.rcDecimals,oracleAddress:this.oracleAddress||"N/A",oracleContractAvailable:!!this.oracleContract}}async handleTradeDataBuySc(e){if(!this.djedContract)throw new Error("DJED contract is not initialized");if("string"!=typeof e)throw new Error("Amount must be a string");try{return(await d.tradeDataPriceBuySc(this.djedContract,this.scDecimals,e)).totalBCScaled}catch(e){throw console.error("Error fetching trade data for buying stablecoins: ",e),e}}}const de=()=>{const{networkSelector:e,tokenSelector:n,selectedNetwork:r,selectedToken:s,selectToken:o,setTransactionDetails:a}=ie(),[i,c]=t.useState(!1),[l,d]=t.useState(null),u=r?n.getAvailableTokens():[];return t.createElement("div",{className:ne.selectField},t.createElement("label",{htmlFor:"token-select"},"Select Token"),t.createElement("select",{id:"token-select",onChange:async t=>{const s=t.target.value;d(null),c(!0);try{if(o(s)){const t=e.getSelectedNetworkConfig(),o=new le(t.uri,t.djedAddress);await o.init();const i=e.getTokenAmount(s),c=o.getBlockchainDetails();let l=null;"native"===s&&(l=await o.handleTradeDataBuySc(String(i))),a({network:r,token:s,tokenSymbol:n.getSelectedToken().symbol,amount:i,receivingAddress:e.getReceivingAddress(),djedContractAddress:t.djedAddress,isDirectTransfer:n.getSelectedToken().isDirectTransfer||!1,isNativeToken:n.getSelectedToken().isNative||!1,tradeAmount:l?l.amount:null,...c})}}catch(e){console.error("Error fetching transaction details:",e),d("Failed to fetch transaction details. Please try again.")}finally{c(!1)}},value:s?s.key:"",disabled:!r||i},t.createElement("option",{value:"",disabled:!0},r?i?"Loading...":"Select a token":"Please select a network first"),u.map(e=>t.createElement("option",{key:e.key,value:e.key},e.symbol," (",e.isDirectTransfer?"Direct Transfer":"Native",")"))),l&&t.createElement("div",{className:ne.error},l))};class ue{constructor(e){if(!e)throw new Error("A provider is required for GasEstimationService.");this.web3=new u(e),this.gasPriceCache={prices:null,timestamp:0}}async getGasPrices(e=!1){const t=Date.now();if(!e&&this.gasPriceCache.prices&&t-this.gasPriceCache.timestamp<6e4)return this.gasPriceCache.prices;try{const e=await this.web3.eth.getGasPrice(),n=parseFloat(this.web3.utils.fromWei(e,"gwei")),r={slow:n.toFixed(2),standard:(1.2*n).toFixed(2),fast:(1.5*n).toFixed(2)};return this.gasPriceCache={prices:r,timestamp:t},r}catch(e){return console.error("Error fetching gas prices:",e),{slow:"5",standard:"10",fast:"15"}}}async estimateGasLimit(e){try{const t=await this.web3.eth.estimateGas(e);return Math.ceil(1.2*t)}catch(e){return console.error("Error estimating gas limit:",e),1e5}}async calculateFee(e,t){const n=await this.getGasPrices(),r=n[e]||n.standard,s=this.web3.utils.toWei(r,"gwei"),o=BigInt(s)*BigInt(t);return this.web3.utils.fromWei(o.toString(),"ether")}async getMaxAmount(e,t,n){const r=await this.calculateFee(t,n),s=BigInt(this.web3.utils.toWei(e,"ether")),o=BigInt(this.web3.utils.toWei(r,"ether"));if(s>o){const e=s-o;return this.web3.utils.fromWei(e.toString(),"ether")}return"0"}}const he={slow:{label:"Slow",time:"~5-10 min"},standard:{label:"Standard",time:"~1-3 min"},fast:{label:"Fast",time:"< 1 min"}},me=({onFeeSelect:e,isNativeTransaction:n})=>{const{client:r}=Y(),[s,o]=t.useState(null),[a,i]=t.useState("standard"),[c,l]=t.useState(!0),[d,u]=t.useState(null),h=t.useMemo(()=>r?new ue(r.transport):null,[r]);return t.useEffect(()=>{if(!h||!n)return void l(!1);const e=async()=>{l(!0),u(null);try{const e=await h.getGasPrices();o(e)}catch(e){console.error("Failed to fetch gas prices:",e),u("Could not load gas fees.")}finally{l(!1)}};e();const t=setInterval(e,6e4);return()=>clearInterval(t)},[h,n]),t.useEffect(()=>{s&&e&&e({speed:a,gwei:s[a]})},[a,s,e]),n?c?t.createElement("div",{className:"stablepay-fee-loading"},"Loading fee estimates..."):d?t.createElement("div",{className:"stablepay-fee-error"},d):t.createElement("div",{className:"stablepay-transaction-fee"},t.createElement("h4",{className:"stablepay-fee-title"},"Transaction Speed"),t.createElement("div",{className:"stablepay-fee-options"},Object.keys(he).map(e=>t.createElement("div",{key:e,className:"stablepay-fee-option "+(a===e?"selected":""),onClick:()=>i(e)},t.createElement("div",{className:"stablepay-fee-label"},he[e].label),t.createElement("div",{className:"stablepay-fee-gwei"},s[e]," Gwei"),t.createElement("div",{className:"stablepay-fee-time"},he[e].time))))):null},pe=({onClose:e,buttonSize:n})=>{const{resetSelections:r}=ie();return t.createElement(re,{onClose:()=>{r(),e()},size:n},t.createElement(ce,null),t.createElement(de,null),t.createElement(me,null))},ge=({onClose:e,buttonSize:n,networkSelector:r})=>t.createElement(ae,{networkSelector:r},t.createElement(K,null,t.createElement(pe,{onClose:e,buttonSize:n}))),fe=({networkSelector:e,buttonSize:n="medium"})=>{const[r,s]=t.useState(!1);return t.createElement("div",{className:ne.widgetContainer},!r&&t.createElement(te,{onClick:()=>{s(!0)},size:n}),r&&t.createElement(ge,{onClose:()=>{s(!1)},buttonSize:n,networkSelector:e}))},we={sepolia:{uri:"https://ethereum-sepolia.publicnode.com/",chainId:11155111,djedAddress:"0x624FcD0a1F9B5820c950FefD48087531d38387f4",tokens:{stablecoin:{symbol:"SOD",address:"0x6b930182787F346F18666D167e8d32166dC5eFBD",decimals:18,isDirectTransfer:!0},native:{symbol:"ETH",decimals:18,isNative:!0}},feeUI:0},"milkomeda-mainnet":{uri:"https://rpc-mainnet-cardano-evm.c1.milkomeda.com",chainId:2001,djedAddress:"0x67A30B399F5Ed499C1a6Bc0358FA6e42Ea4BCe76",tokens:{stablecoin:{symbol:"MOD",address:"0xcbA90fB1003b9D1bc6a2b66257D2585011b004e9",decimals:18,isDirectTransfer:!0},native:{symbol:"mADA",decimals:18,isNative:!0}},feeUI:0},"ethereum-classic":{uri:"https://etc.rivet.link",chainId:61,djedAddress:"0xCc3664d7021FD36B1Fe2b136e2324710c8442cCf",tokens:{stablecoin:{symbol:"ECSD",address:"0x5A7Ca94F6E969C94bef4CE5e2f90ed9d4891918A",decimals:18,isDirectTransfer:!0},native:{symbol:"ETC",decimals:18,isNative:!0}},feeUI:0}};class ve{constructor(e={}){this.receivingAddress=e.receivingAddress||"",this.blacklist=e.blacklist||[],this.amounts=e.Amounts||{},this.validateConfig()}validateConfig(){if(!this.receivingAddress)throw new Error("Receiving address is required");for(const[e,t]of Object.entries(this.amounts)){if(!we[e])throw new Error(`Invalid network: ${e}`);if(!t.stablecoin||"number"!=typeof t.stablecoin||t.stablecoin<=0)throw new Error(`Invalid stablecoin amount for network ${e}`)}}getBlacklist(){return this.blacklist}getReceivingAddress(){return this.receivingAddress}getTokenAmount(e){console.log("Getting amount for network:",e),console.log("Amounts object:",this.amounts);const t=this.amounts[e]?.stablecoin;return console.log("Returning amount:",t),t||0}}class be{constructor(e){this.merchantConfig=e,this.blacklist=e.getBlacklist(),this.availableNetworks=this.getAvailableNetworks(),this.selectedNetwork=null}getAvailableNetworks(){return Object.entries(we).reduce((e,[t,n])=>(this.blacklist.includes(n.chainId)||(e[t]=n),e),{})}selectNetwork(e){return null===e?(this.selectedNetwork=null,console.log("Network selection reset"),!0):this.availableNetworks[e]?(this.selectedNetwork=e,console.log(`Network selected: ${e}`),!0):(console.error(`Invalid network: ${e}`),!1)}getSelectedNetworkConfig(){return this.selectedNetwork?this.availableNetworks[this.selectedNetwork]:null}getReceivingAddress(){return this.merchantConfig.getReceivingAddress()}getTokenAmount(e){return this.merchantConfig.getTokenAmount(this.selectedNetwork,e)}}const ye={MerchantConfig:ve,NetworkSelector:be,Widget:fe,init:({target:e,networkSelector:n,theme:r,buttonSize:s="medium",...o})=>{const a=document.querySelector(e);if(!a)return console.error(`StablePay Error: Target element "${e}" not found.`),{destroy:()=>{}};if(!n)return console.error("StablePay Error: `networkSelector` is required."),{destroy:()=>{}};const i=y(a);return i.render(t.createElement(t.StrictMode,null,t.createElement(H,{themeConfig:r},t.createElement(fe,w({networkSelector:n,buttonSize:s},o))))),{destroy:()=>{i.unmount()}}}};e.MerchantConfig=ve,e.NetworkSelector=be,e.ThemeProvider=H,e.WalletContextProvider=K,e.Widget=fe,e.default=ye,e.useNetwork=ie,e.useWallet=Y,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
