!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("djed-sdk"),require("djed-sdk/src/artifacts/CoinABI.json"),require("react"),require("viem"),require("viem/chains")):"function"==typeof define&&define.amd?define(["djed-sdk","djed-sdk/src/artifacts/CoinABI.json","react","viem","viem/chains"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).StablePay=t(e.DjedSdk,e.coinArtifact,e.React,e.viem,e.viemChains)}(this,(function(e,t,a,n,s){"use strict";const r={sepolia:{uri:"https://ethereum-sepolia.publicnode.com/",chainId:11155111,stablecoins:[{id:"djed-eth-sepolia",name:"Djed (ETH Backed)",protocol:"djed",contractAddress:"0x624FcD0a1F9B5820c950FefD48087531d38387f4",baseAsset:{symbol:"ETH",decimals:18,isNative:!0,address:null},stableCoin:{symbol:"SOD",address:"0x6b930182787F346F18666D167e8d32166dC5eFBD",decimals:18,isDirectTransfer:!0}}],feeUI:0},"milkomeda-mainnet":{uri:"https://rpc-mainnet-cardano-evm.c1.milkomeda.com",chainId:2001,stablecoins:[{id:"djed-mada",name:"Djed (mADA Backed)",protocol:"djed",contractAddress:"0x67A30B399F5Ed499C1a6Bc0358FA6e42Ea4BCe76",baseAsset:{symbol:"mADA",decimals:18,isNative:!0,address:null},stableCoin:{symbol:"MOD",address:"0xcbA90fB1003b9D1bc6a2b66257D2585011b004e9",decimals:18,isDirectTransfer:!0}},{id:"djed-usdt-isis",name:"Djed (USDT Backed)",protocol:"isis",contractAddress:"0x0000000000000000000000000000000000000000",baseAsset:{symbol:"USDT",decimals:6,isNative:!1,address:"0x0000000000000000000000000000000000000000"},stableCoin:{symbol:"iUSD",address:"0x0000000000000000000000000000000000000000",decimals:18,isDirectTransfer:!0}}],feeUI:0},"ethereum-classic":{uri:"https://etc.rivet.link",chainId:61,stablecoins:[{id:"djed-etc",name:"Djed (ETC Backed)",protocol:"djed",contractAddress:"0xCc3664d7021FD36B1Fe2b136e2324710c8442cCf",baseAsset:{symbol:"ETC",decimals:18,isNative:!0,address:null},stableCoin:{symbol:"ECSD",address:"0x5A7Ca94F6E969C94bef4CE5e2f90ed9d4891918A",decimals:18,isDirectTransfer:!0}}],feeUI:0}};class i{constructor(e,t){this.networkUri=e,this.config=t,this.djedAddress=t.contractAddress,this.baseAsset=t.baseAsset}async init(){if(!this.networkUri||!this.djedAddress)throw new Error("Network URI and DJED address are required");try{this.web3=await e.getWeb3(this.networkUri),this.djedContract=e.getDjedContract(this.web3,this.djedAddress),!this.baseAsset.isNative&&this.baseAsset.address&&(this.baseAssetContract=new this.web3.eth.Contract(t.abi,this.baseAsset.address));try{const{stableCoin:t,reserveCoin:a}=await e.getCoinContracts(this.djedContract,this.web3),{scDecimals:n,rcDecimals:s}=await e.getDecimals(t,a);this.stableCoin=t,this.reserveCoin=a,this.scDecimals=n,this.rcDecimals=s,this.oracleContract=await e.getOracleAddress(this.djedContract).then((t=>e.getOracleContract(this.web3,t,this.djedContract._address))),this.oracleAddress=this.oracleContract._address}catch(e){throw console.error("[Transaction] Error fetching contract details:",e),e}}catch(e){throw console.error("[Transaction] Error initializing transaction:",e),e}}getBlockchainDetails(){return{web3Available:!!this.web3,djedContractAvailable:!!this.djedContract,stableCoinAddress:this.stableCoin?this.stableCoin._address:"N/A",reserveCoinAddress:this.reserveCoin?this.reserveCoin._address:"N/A",stableCoinDecimals:this.scDecimals,reserveCoinDecimals:this.rcDecimals,oracleAddress:this.oracleAddress||"N/A",oracleContractAvailable:!!this.oracleContract,baseAssetSymbol:this.baseAsset.symbol,baseAssetIsNative:this.baseAsset.isNative,baseAssetDecimals:this.baseAsset.decimals}}async handleTradeDataBuySc(t){if(!this.djedContract)throw new Error("DJED contract is not initialized");try{return(await e.tradeDataPriceBuySc(this.djedContract,this.scDecimals,t)).totalBCScaled}catch(e){throw console.error("Error fetching trade data for buying stablecoins: ",e),e}}async buyStablecoins(t,a,n){if(!this.djedContract)throw new Error("DJED contract is not initialized");try{const s="0x0232556C83791b8291E9b23BfEa7d67405Bd9839";if(this.baseAsset.isNative)return e.buyScTx(this.djedContract,t,a,n,s,this.djedAddress);if(!this.baseAssetContract)throw new Error("Base Asset contract not initialized for ERC20 flow");return e.buyScIsisTx(this.djedContract,t,a,n,s,this.djedAddress)}catch(e){throw console.error("Error executing buyStablecoins transaction: ",e),e}}async approveBaseAsset(t,a){if(this.baseAsset.isNative)throw new Error("Cannot approve native asset");if(!this.baseAssetContract)throw new Error("No Base Asset contract to approve");return e.approveTx(this.baseAssetContract,t,this.djedAddress,a)}async checkBaseAssetAllowance(t,a){if(this.baseAsset.isNative)return!0;if(!this.baseAssetContract)return!1;const n=await e.checkAllowance(this.baseAssetContract,t,this.djedAddress);return BigInt(n)>=BigInt(a)}}var o="main_stablePayButton__UA7HC",c="main_logo__ITyEy",l="main_buttonText__N-ewy";const d=({onClick:e,size:t="medium"})=>{const n={small:{width:"200px",height:"50px",fontSize:"14px"},medium:{width:"250px",height:"60px",fontSize:"16px"},large:{width:"300px",height:"70px",fontSize:"18px"}},s={small:{width:"35px",height:"33px"},medium:{width:"40px",height:"38px"},large:{width:"45px",height:"43px"}},r=n[t]||n.medium,i=s[t]||s.medium;return a.createElement("button",{className:o,onClick:e,style:r},a.createElement("div",{className:c,style:i}),a.createElement("span",{className:l},"Pay with StablePay"))};var u={dialogOverlay:"PricingCard_dialogOverlay__0XJrE",pricingCard:"PricingCard_pricingCard__LrWb9",small:"PricingCard_small__J4CHj",medium:"PricingCard_medium__EVmTB",large:"PricingCard_large__A6pnX",dialogClose:"PricingCard_dialogClose__jJ1tM",pricingCardHeader:"PricingCard_pricingCardHeader__wGczA",allianceLogo:"PricingCard_allianceLogo__URa-U",stablepayTitle:"PricingCard_stablepayTitle__4t848",pricingCardBody:"PricingCard_pricingCardBody__0wKQn",selectField:"PricingCard_selectField__LBPoZ",transactionReview:"PricingCard_transactionReview__Ix-eL",transactionInfo:"PricingCard_transactionInfo__Ck-Rc",transactionLabel:"PricingCard_transactionLabel__GDux7",transactionValue:"PricingCard_transactionValue__q-xxp",infoSection:"PricingCard_infoSection__gyjMQ",infoIcon:"PricingCard_infoIcon__rraxD",infoText:"PricingCard_infoText__l4b7A",walletButton:"PricingCard_walletButton__llw4v",loading:"PricingCard_loading__2-tGA",error:"PricingCard_error__m5fK-",networkError:"PricingCard_networkError__zR-36",errorText:"PricingCard_errorText__qZRJt","message-box":"PricingCard_message-box__vkUKy",detailsButton:"PricingCard_detailsButton__jHglL",errorDetails:"PricingCard_errorDetails__CzN-7",loadingContainer:"PricingCard_loadingContainer__6nOVa",spinner:"PricingCard_spinner__9ucQv",spin:"PricingCard_spin__24tni"};const m=({children:e,onClose:t,size:n="medium"})=>a.createElement("div",{className:u.dialogOverlay},a.createElement("div",{className:`${u.pricingCard} ${u[n]}`},a.createElement("button",{className:u.dialogClose,onClick:t},"×"),a.createElement("div",{className:u.pricingCardHeader},a.createElement("div",{className:u.allianceLogo}),a.createElement("h2",{className:u.stablepayTitle},"StablePay")),a.createElement("div",{className:u.pricingCardBody},e)));class h{constructor(e){this.networkSelector=e,this.selectedToken=null}selectToken(e){const t=this.getAvailableTokens().find((t=>t.key===e));return!!t&&(this.selectedToken=t,!0)}getSelectedToken(){return this.selectedToken}getAvailableTokens(){const e=this.networkSelector.getSelectedNetworkConfig();return e&&e.stablecoins?e.stablecoins.map((e=>({key:e.id,name:e.name,symbol:e.stableCoin.symbol,baseAsset:e.baseAsset.symbol,isDirectTransfer:e.stableCoin.isDirectTransfer,config:e}))):[]}resetSelection(){this.selectedToken=null}}const w=a.createContext(),b=({children:e,networkSelector:t})=>{const[n]=a.useState((()=>new h(t))),[s,r]=a.useState(null),[i,o]=a.useState(null),[c,l]=a.useState(null),d=()=>{o(null),l(null)};return a.useEffect((()=>{r(t.selectedNetwork)}),[t.selectedNetwork]),a.createElement(w.Provider,{value:{networkSelector:t,tokenSelector:n,selectedNetwork:s,selectedToken:i,transactionDetails:c,setTransactionDetails:l,selectNetwork:e=>!!t.selectNetwork(e)&&(r(e),d(),!0),selectToken:e=>{if(n.selectToken(e)){const e=n.getSelectedToken();return o(e),!0}return!1},resetSelections:()=>{t.selectNetwork(null),r(null),d()}}},e)},C=()=>{const e=a.useContext(w);if(void 0===e)throw new Error("useNetwork must be used within a NetworkProvider");return e},k=()=>{const{networkSelector:e,selectedNetwork:t,selectNetwork:n}=C();return a.createElement("div",{className:u.selectField},a.createElement("label",{htmlFor:"network-select"},"Select Network"),a.createElement("select",{id:"network-select",onChange:e=>{n(e.target.value)},value:t||""},a.createElement("option",{value:"",disabled:!0},"Select a network"),Object.keys(e.availableNetworks).map((e=>a.createElement("option",{key:e,value:e},e)))))},g=()=>{const{networkSelector:e,tokenSelector:t,selectedNetwork:n,selectedToken:s,selectToken:r,setTransactionDetails:o}=C(),[c,l]=a.useState(!1),[d,m]=a.useState(null),h=n?t.getAvailableTokens():[];return a.createElement("div",{className:u.selectField},a.createElement("label",{htmlFor:"token-select"},"Select Token"),a.createElement("select",{id:"token-select",onChange:async t=>{const a=t.target.value;m(null),l(!0);try{if(r(a)){const t=e.getSelectedNetworkConfig(),s=t.stablecoins.find((e=>e.id===a));if(!s)throw new Error("Stablecoin configuration not found");const r=new i(t.uri,s);await r.init();const c=e.getTokenAmount(a),l=r.getBlockchainDetails();o({network:n,token:a,tokenSymbol:s.stableCoin.symbol,amount:c,receivingAddress:e.getReceivingAddress(),djedContractAddress:s.contractAddress,isDirectTransfer:s.stableCoin.isDirectTransfer||!1,baseAssetSymbol:s.baseAsset.symbol,baseAssetDecimals:s.baseAsset.decimals,baseAssetIsNative:s.baseAsset.isNative,...l})}}catch(e){console.error("Error updating transaction details:",e),m("Failed to initialize transaction.")}finally{l(!1)}},value:s?s.key:"",disabled:!n||c},a.createElement("option",{value:"",disabled:!0},n?c?"Loading...":"Select a token":"Please select a network first"),h.map((e=>a.createElement("option",{key:e.key,value:e.key},e.symbol," (",e.isDirectTransfer?"Direct Transfer":"Native",")")))),d&&a.createElement("div",{className:u.error},d))};n.defineChain({id:63,name:"Mordor Testnet",network:"mordor",nativeCurrency:{decimals:18,name:"Mordor Ether",symbol:"METC"},rpcUrls:{default:{http:["https://rpc.mordor.etccooperative.org"],webSocket:["wss://rpc.mordor.etccooperative.org/ws"]}},blockExplorers:{default:{name:"BlockScout",url:"https://blockscout.com/etc/mordor"}},testnet:!0});const p=n.defineChain({id:2001,name:"Milkomeda C1 Mainnet",network:"milkomeda",nativeCurrency:{decimals:18,name:"Milkomeda ADA",symbol:"mADA"},rpcUrls:{default:{http:["https://rpc-mainnet-cardano-evm.c1.milkomeda.com"]}},blockExplorers:{default:{name:"Milkomeda Explorer",url:"https://explorer-mainnet-cardano-evm.c1.milkomeda.com"}},testnet:!1}),f=n.defineChain({id:61,name:"Ethereum Classic",network:"etc",nativeCurrency:{decimals:18,name:"Ethereum Classic",symbol:"ETC"},rpcUrls:{default:{http:["https://etc.rivet.link"]}},blockExplorers:{default:{name:"Blockscout",url:"https://blockscout.com/etc/mainnet"}},testnet:!1}),A=a.createContext(null),v=async e=>{if(!window.ethereum)throw new Error("MetaMask not installed");const t=(e=>{switch(e){case"sepolia":return{chainId:`0x${s.sepolia.id.toString(16)}`,chainName:"Sepolia",nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},rpcUrls:s.sepolia.rpcUrls.default.http,blockExplorerUrls:s.sepolia.blockExplorers?.default?.url?[s.sepolia.blockExplorers.default.url]:[]};case"ethereum-classic":return{chainId:`0x${f.id.toString(16)}`,chainName:"Ethereum Classic",nativeCurrency:{name:"Ethereum Classic",symbol:"ETC",decimals:18},rpcUrls:["https://etc.rivet.link"],blockExplorerUrls:["https://blockscout.com/etc/mainnet"]};case"milkomeda-mainnet":return{chainId:`0x${p.id.toString(16)}`,chainName:"Milkomeda C1 Mainnet",nativeCurrency:{name:"Milkomeda ADA",symbol:"mADA",decimals:18},rpcUrls:["https://rpc-mainnet-cardano-evm.c1.milkomeda.com"],blockExplorerUrls:["https://explorer-mainnet-cardano-evm.c1.milkomeda.com"]};default:return null}})(e);if(!t)throw new Error(`Unsupported network: ${e}`);try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t.chainId}]})}catch(e){if(4902!==e.code)throw 4001===e.code?new Error(`User rejected switching to ${t.chainName}. Please switch manually in MetaMask.`):new Error(`Failed to switch to ${t.chainName}: ${e.message}`);try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[t]})}catch(e){if(4001===e.code)throw new Error(`User rejected adding ${t.chainName} to MetaMask. Please add it manually.`);throw new Error(`Failed to add ${t.chainName} to MetaMask: ${e.message}`)}}},E=({children:e})=>{const{selectedNetwork:t}=C(),[r,i]=a.useState(null),[o,c]=a.useState(null),[l,d]=a.useState(null),[u,m]=a.useState(null),[h,w]=a.useState(null),[b,k]=a.useState(null),[g,E]=a.useState(!1),y=t?(e=>{switch(e){case"sepolia":return s.sepolia;case"ethereum-classic":return f;case"milkomeda-mainnet":return p;default:return null}})(t):null,_=y?y.id:null,S=a.useRef(null),N=a.useRef(null),T=a.useCallback((()=>{i(null),c(null),d(null),m(null),w(null),k(null)}),[]),D=a.useCallback((async e=>{const a=parseInt(e,16);if(m(a),y&&a===_){if(k(null),window.ethereum&&y){const e=n.createWalletClient({chain:y,transport:n.custom(window.ethereum)});i(e)}}else if(y&&a!==_){k(`Wrong network detected. Please switch to ${y?.name||t||"selected network"}`)}}),[y,_,t]);N.current=D;const x=a.useCallback((async e=>{if(0===e.length){if(T(),window.ethereum){const e=S.current,t=N.current;e&&window.ethereum.removeListener("accountsChanged",e),t&&window.ethereum.removeListener("chainChanged",t)}}else if(d(e[0]),y)try{const t=n.createPublicClient({chain:y,transport:n.http()});c(t);const a=await t.getBalance({address:e[0]});w(parseFloat(a)/Math.pow(10,18))}catch(e){console.error("Error fetching balance:",e),w(null)}}),[y,T]);S.current=x;const P=a.useCallback((()=>{if(T(),window.ethereum){const e=S.current,t=N.current;e&&window.ethereum.removeListener("accountsChanged",e),t&&window.ethereum.removeListener("chainChanged",t)}}),[T]),B=a.useCallback((()=>{y&&c(n.createPublicClient({chain:y,transport:n.http()}))}),[y]),j=a.useCallback((async()=>{if(!window.ethereum)return k("Please install MetaMask or another Web3 wallet"),!1;if(!t||!y)return k("Please select a network first"),!1;E(!0),k(null);try{const e=await window.ethereum.request({method:"eth_requestAccounts"});if(0===e.length)throw new Error("No wallet address found. Please unlock your wallet.");const a=await window.ethereum.request({method:"eth_chainId"});parseInt(a,16)!==_&&await v(t);const s=n.createWalletClient({chain:y,transport:n.custom(window.ethereum)});i(s),d(e[0]),m(_);const r=n.createPublicClient({chain:y,transport:n.http()});c(r);try{const t=await r.getBalance({address:e[0]});w(parseFloat(t)/Math.pow(10,18))}catch(e){console.error("Error fetching balance:",e),w(null)}return S.current=x,N.current=D,window.ethereum.on("accountsChanged",x),window.ethereum.on("chainChanged",D),!0}catch(e){return console.error("Error connecting wallet:",e),k(e.message),!1}finally{E(!1)}}),[t,y,_,x,D]),I=a.useCallback((async()=>{if(!(window.ethereum&&t&&y&&l)){return k("Wallet not connected or network not selected"),null}try{const e=await window.ethereum.request({method:"eth_chainId"});if(parseInt(e,16)!==_){k(null),await v(t);const e=500;await new Promise((t=>setTimeout(t,e)));const a=await window.ethereum.request({method:"eth_chainId"}),n=parseInt(a,16);if(n!==_)throw new Error(`Failed to switch network. MetaMask is still on chain ${n}, expected ${_}`)}const a=n.createWalletClient({chain:y,transport:n.custom(window.ethereum)});return i(a),m(_),k(null),a}catch(e){return k(e.message),null}}),[t,y,_,l]),U=a.useRef(t);return a.useEffect((()=>{if(null!==U.current&&U.current!==t&&l&&(T(),window.ethereum)){const e=S.current,t=N.current;e&&window.ethereum.removeListener("accountsChanged",e),t&&window.ethereum.removeListener("chainChanged",t)}U.current=t}),[t,l,T]),a.useEffect((()=>{B()}),[B]),a.createElement(A.Provider,{value:{walletClient:r,publicClient:o,account:l,chainId:u,balance:h,error:b,isConnecting:g,connectWallet:j,disconnectWallet:P,ensureCorrectNetwork:I,expectedChainId:_}},e)},y=({onTransactionComplete:e})=>{const{networkSelector:t,tokenSelector:s,selectedNetwork:r,selectedToken:o,transactionDetails:c,setTransactionDetails:l}=C(),{connectWallet:d,account:m,walletClient:h,ensureCorrectNetwork:w,isConnecting:b}=(()=>{const e=a.useContext(A);if(!e)throw new Error("useWallet must be used within a WalletProvider");return e})(),[k,g]=a.useState(null),[p,f]=a.useState(null),[v,E]=a.useState(""),[y,_]=a.useState(null),[S,N]=a.useState(null);a.useState(!1);const[T,D]=a.useState(!1),[x,P]=a.useState(!1);a.useEffect((()=>{f(null),E(""),N(null),_(null),D(!1)}),[r,o]),a.useEffect((()=>{(async()=>{if(r&&o)try{const e=t.getSelectedNetworkConfig(),a=s.getSelectedToken().config,n=new i(e.uri,a);await n.init(),g(n);const c=t.getTokenAmount(o.key);let d=null;try{d=await n.handleTradeDataBuySc(String(c))}catch(e){console.error("Error fetching trade data:",e)}l({network:r,token:o.key,tokenSymbol:o.symbol,amount:c||"0",receivingAddress:t.getReceivingAddress(),tradeAmount:d,...n.getBlockchainDetails()}),m&&(!a.baseAsset.isNative&&d?B(n,m,d,a.baseAsset.decimals):a.baseAsset.isNative&&D(!0))}catch(e){console.error("Error initializing transaction:",e)}})()}),[r,o,t,m]);const B=async(e,t,a,s)=>{try{const r=n.parseUnits(String(a),s),i=await e.checkBaseAssetAllowance(t,r);D(i)}catch(e){console.error("Error checking allowance",e)}};return a.createElement("div",{className:u.transactionReview},a.createElement("div",{className:u.transactionInfo},a.createElement("span",{className:u.transactionLabel},"Network:"),a.createElement("span",{className:u.transactionValue},c.network)),a.createElement("div",{className:u.transactionInfo},a.createElement("span",{className:u.transactionLabel},"You Pay:"),a.createElement("span",{className:u.transactionValue},c.tradeAmount?`${c.tradeAmount} ${c.baseAssetSymbol}`:"Calculating...")),a.createElement("button",{className:u.walletButton,onClick:async()=>{await d()},disabled:b},b?"Connecting...":m?`Connected: ${m.slice(0,6)}...`:"Connect Wallet"),m&&!c.baseAssetIsNative&&!T&&a.createElement("button",{className:u.walletButton,onClick:async()=>{if(k&&m){P(!0),E("⏳ Approving token usage...");try{const{tradeAmount:e,baseAssetDecimals:t}=c,a=n.parseUnits(String(e),t),s=await k.approveBaseAsset(m,a),r=await w(),i=await r.sendTransaction({...s,account:m});E("⏳ Approval Sent. Waiting...");"success"===(await h.waitForTransactionReceipt({hash:i})).status?(D(!0),E("✅ Approved! You can now send the payment.")):E("❌ Approval transaction failed on-chain."),P(!1)}catch(e){console.error(e),N(e),E("❌ Approval failed."),P(!1)}}},disabled:x},x?"Approving...":`Approve ${c.baseAssetSymbol}`),m&&(c.baseAssetIsNative||T)&&!p&&a.createElement("button",{className:u.walletButton,onClick:async()=>{if(m&&k)try{f(null),N(null),E("⏳ Preparing transaction...");const{tradeAmount:e,receivingAddress:t,baseAssetDecimals:a,baseAssetIsNative:s}=c,r=n.parseUnits(String(e),a),i={...await k.buyStablecoins(m,t,r),account:m};i.value=s?r:0n,f(i),E("✅ Transaction ready! Click 'Send Transaction' to proceed.")}catch(e){N(e),E("❌ Transaction preparation failed.")}}},"Prepare Transaction"),m&&p&&a.createElement("button",{className:u.walletButton,onClick:async()=>{try{if(!m||!p)return;const t=await w();E("⏳ Sending transaction...");const a=await t.sendTransaction(p);_(a),E("✅ Transaction sent!"),e&&e({txHash:a,network:r,amount:c?.amount})}catch(e){N(e),E("❌ Transaction failed.")}},disabled:null!==y},"Send Transaction"),v&&a.createElement("div",{className:"message-box"},v),y&&a.createElement("div",{className:u.transactionLink},"✅ Transaction Hash: ",y.slice(0,10),"..."))},_=({onClose:e,buttonSize:t,onTransactionComplete:n})=>{const{resetSelections:s}=C();return a.createElement(m,{onClose:()=>{s(),e()},size:t},a.createElement(k,null),a.createElement(g,null),a.createElement(y,{onTransactionComplete:n}))},S=({onClose:e,buttonSize:t,networkSelector:n,onTransactionComplete:s})=>a.createElement(b,{networkSelector:n},a.createElement(E,null,a.createElement(_,{onClose:e,buttonSize:t,onTransactionComplete:s})));return{NetworkSelector:class{constructor(e){this.merchantConfig=e,this.blacklist=e.getBlacklist(),this.availableNetworks=this.getAvailableNetworks(),this.selectedNetwork=null}getAvailableNetworks(){return Object.entries(r).reduce(((e,[t,a])=>(this.blacklist.includes(a.chainId)||(e[t]=a),e)),{})}selectNetwork(e){return null===e?(this.selectedNetwork=null,console.log("Network selection reset"),!0):this.availableNetworks[e]?(this.selectedNetwork=e,console.log(`Network selected: ${e}`),!0):(console.error(`Invalid network: ${e}`),!1)}getSelectedNetworkConfig(){return this.selectedNetwork?this.availableNetworks[this.selectedNetwork]:null}getReceivingAddress(){return this.merchantConfig.getReceivingAddress()}getTokenAmount(e,t){console.log("Getting amount for network:",e),console.log("Amounts object:",this.amounts);return(this.amounts[e]?.[t]??this.amounts[e]?.stablecoin)||0}},Transaction:i,Config:class{constructor(e={}){this.receivingAddress=e.receivingAddress||"",this.blacklist=e.blacklist||[],this.amounts=e.Amounts||{},this.validateConfig()}validateConfig(){if(!this.receivingAddress)throw new Error("Receiving address is required");for(const[e,t]of Object.entries(this.amounts)){if(!r[e])throw new Error(`Invalid network: ${e}`);if(!t.stablecoin||"number"!=typeof t.stablecoin||t.stablecoin<=0)throw new Error(`Invalid stablecoin amount for network ${e}`)}}getBlacklist(){return this.blacklist}getReceivingAddress(){return this.receivingAddress}getTokenAmount(e){console.log("Getting amount for network:",e),console.log("Amounts object:",this.amounts);const t=this.amounts[e]?.stablecoin;return console.log("Returning amount:",t),t||0}},Widget:({networkSelector:e,buttonSize:t="medium",onTransactionComplete:n,onSuccess:s})=>{const[r,i]=a.useState(!1),o=n||s;return a.createElement("div",{className:u.widgetContainer},!r&&a.createElement(d,{onClick:()=>{i(!0)},size:t}),r&&a.createElement(S,{onClose:()=>{i(!1)},buttonSize:t,networkSelector:e,onTransactionComplete:o}))},PayButton:d,Dialog:m,NetworkDropdown:k}}));
//# sourceMappingURL=index.js.map
